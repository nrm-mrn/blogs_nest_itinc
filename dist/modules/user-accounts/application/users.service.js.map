{"version":3,"sources":["../../../../src/modules/user-accounts/application/users.service.ts"],"sourcesContent":["import { Injectable } from '@nestjs/common';\nimport { CreateUserDto } from '../dto/create-user.dto';\nimport { UsersRepository } from '../infrastructure/users.repository';\nimport { HashService } from '../adapters/passHash.service';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { User, UserDocument, UserModelType } from '../domain/user.entity';\nimport {\n  DomainException,\n  Extension,\n} from 'src/core/exceptions/domain-exceptions';\nimport { DomainExceptionCode } from 'src/core/exceptions/domain-exception-codes';\nimport { EmailConfirmation } from '../domain/emailConfirmation.schema';\nimport { ConfigService } from '@nestjs/config';\nimport { ConfigurationType } from 'src/modules/config/config.module';\nimport { Duration } from 'luxon';\nimport { UUID } from 'crypto';\nimport { PasswordRecovery } from '../domain/passRecovery.schema';\nimport { ConfirmPasswordDto } from '../dto/confirm-password.dto';\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectModel(User.name) private readonly UserModel: UserModelType,\n    private readonly usersRepository: UsersRepository,\n    private readonly hashService: HashService,\n    private readonly configService: ConfigService<ConfigurationType>,\n  ) {}\n\n  async createUser(input: CreateUserDto): Promise<{ userId: string }> {\n    const uniqueLogin = await this.isLoginUnique(input.login);\n    if (!uniqueLogin) {\n      throw new DomainException({\n        code: DomainExceptionCode.BadRequest,\n        message: 'Login already exists',\n        extensions: [new Extension('Login already exist', 'login')],\n      });\n    }\n    const uniqueEmail = await this.isEmailUnique(input.email);\n    if (!uniqueEmail) {\n      throw new DomainException({\n        code: DomainExceptionCode.BadRequest,\n        message: 'Email already exists',\n        extensions: [new Extension('Email already exist', 'email')],\n      });\n    }\n\n    const hash = await this.hashService.createHash(input.password);\n    const newUser = this.UserModel.createUser({\n      email: input.email,\n      login: input.login,\n      passHash: hash,\n    });\n    const userId = await this.usersRepository.save(newUser);\n\n    return { userId };\n  }\n\n  async isLoginUnique(login: string): Promise<boolean> {\n    const loginRes = await this.usersRepository.findUserByLoginOrEmail(login);\n    if (loginRes) {\n      return false;\n    }\n    return true;\n  }\n\n  async isEmailUnique(email: string): Promise<boolean> {\n    const emailRes = await this.usersRepository.findUserByLoginOrEmail(email);\n    if (emailRes) {\n      return false;\n    }\n    return true;\n  }\n\n  async findUserById(id: string): Promise<UserDocument | null> {\n    return this.usersRepository.findById(id);\n  }\n\n  async getUserByLoginOrEmail(input: string): Promise<UserDocument> {\n    const user = await this.usersRepository.findUserByLoginOrEmail(input);\n    if (!user) {\n      throw new DomainException({\n        code: DomainExceptionCode.NotFound,\n        message: 'User not found',\n      });\n    }\n    return user;\n  }\n\n  async deleteUser(userId: string) {\n    const user = await this.usersRepository.findOrNotFoundFail(userId);\n    await this.usersRepository.deleteUser(user);\n  }\n\n  async createEmailConfirmation(email: string): Promise<EmailConfirmation> {\n    const user = await this.usersRepository.findUserByEmail(email);\n    if (!user) {\n      throw new DomainException({\n        code: DomainExceptionCode.BadRequest,\n        message: 'User with provided email do not exist',\n        extensions: [\n          new Extension('User with provided email do not exist', 'email'),\n        ],\n      });\n    }\n    user.genEmailConfirmation(\n      this.configService.get('emailExpiration') as Duration,\n    );\n    await this.usersRepository.save(user);\n    return user.emailConfirmation as EmailConfirmation;\n  }\n\n  async confirmEmail(code: UUID): Promise<void> {\n    const user = await this.usersRepository.findUserByEmailConfirmation(code);\n    if (!user) {\n      throw new DomainException({\n        code: DomainExceptionCode.BadRequest,\n        message: 'User with provided code does not exist',\n        extensions: [\n          new Extension('User with provided code does not exist', 'code'),\n        ],\n      });\n    }\n    user.confirmEmail();\n    await this.usersRepository.save(user);\n    return;\n  }\n\n  async setPasswordRecovery(email: string): Promise<PasswordRecovery | null> {\n    const user = await this.usersRepository.findUserByEmail(email);\n    if (!user) {\n      return null;\n    }\n    user.genPasswordRecovery(\n      this.configService.get('passRecoveryExpiration') as Duration,\n    );\n    await this.usersRepository.save(user);\n    return user.passwordRecovery as PasswordRecovery;\n  }\n\n  async confirmPassword(input: ConfirmPasswordDto): Promise<void> {\n    const user = await this.usersRepository.getUserByPassRecovery(input.code);\n    if (!user) {\n      throw new DomainException({\n        code: DomainExceptionCode.BadRequest,\n        message: 'Incorrect recovery code',\n        extensions: [new Extension('incorrect recovery code', 'recoveryCode')],\n      });\n    }\n    const hash = await this.hashService.createHash(input.password);\n    user.confirmPassword(hash);\n    await this.usersRepository.save(user);\n    return;\n  }\n}\n"],"names":["UsersService","createUser","input","uniqueLogin","isLoginUnique","login","DomainException","code","DomainExceptionCode","BadRequest","message","extensions","Extension","uniqueEmail","isEmailUnique","email","hash","hashService","createHash","password","newUser","UserModel","passHash","userId","usersRepository","save","loginRes","findUserByLoginOrEmail","emailRes","findUserById","id","findById","getUserByLoginOrEmail","user","NotFound","deleteUser","findOrNotFoundFail","createEmailConfirmation","findUserByEmail","genEmailConfirmation","configService","get","emailConfirmation","confirmEmail","findUserByEmailConfirmation","setPasswordRecovery","genPasswordRecovery","passwordRecovery","confirmPassword","getUserByPassRecovery","constructor","name"],"mappings":"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"}