{"version":3,"sources":["../../../../src/modules/user-accounts/application/devices-security.service.ts"],"sourcesContent":["import { Inject, Injectable } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { DevicesSecurityRepository } from '../infrastructure/devices-security.repository';\nimport { InjectModel } from '@nestjs/mongoose';\nimport {\n  DeviceAuthSession,\n  SessionDocument,\n  SessionModelType,\n} from '../domain/session.entity';\nimport mongoose from 'mongoose';\nimport { CreateSessionDto } from '../dto/create-session.dto';\nimport { DateTime, Duration } from 'luxon';\nimport { ConfigService } from '@nestjs/config';\nimport { ConfigurationType } from 'src/modules/config/config.module';\nimport { DomainException } from 'src/core/exceptions/domain-exceptions';\nimport { DomainExceptionCode } from 'src/core/exceptions/domain-exception-codes';\nimport { CreateRefreshTokenDto } from '../dto/create-refresh-token.dto';\nimport { REFRESH_TOKEN_STRATEGY_INJECT_TOKEN } from '../constants/auth-token.inject-constants';\n\n@Injectable()\nexport class SessionsService {\n  constructor(\n    @InjectModel(DeviceAuthSession.name)\n    private readonly SessionModel: SessionModelType,\n    private readonly sessionsRepository: DevicesSecurityRepository,\n    @Inject(REFRESH_TOKEN_STRATEGY_INJECT_TOKEN)\n    private readonly jwtRefreshTokService: JwtService,\n    private readonly configService: ConfigService<ConfigurationType>,\n  ) {}\n\n  async saveSession(input: CreateSessionDto): Promise<{ deviceId: string }> {\n    const domainInput = {\n      ...input,\n      deviceId: new mongoose.Types.ObjectId(input.deviceId),\n      expiration: DateTime.utc()\n        .plus(\n          Duration.fromMillis(\n            this.configService.get('refreshTokenDuration') * 60 * 1000,\n          ),\n        )\n        .toJSDate(),\n    };\n    const session = this.SessionModel.createSession(domainInput);\n\n    const deviceId = await this.sessionsRepository.save(session);\n    return { deviceId };\n  }\n\n  async getSession(deviceId: string, iat: number): Promise<SessionDocument> {\n    const timestamp = new Date(iat);\n    const session = await this.sessionsRepository.findSessionOrFail(\n      deviceId,\n      timestamp,\n    );\n    return session;\n  }\n\n  async refreshSession(deviceId: string, newIat: number): Promise<void> {\n    const session =\n      await this.sessionsRepository.findSessionByDeviceId(deviceId);\n    if (!session) {\n      throw new DomainException({\n        code: DomainExceptionCode.InternalServerError,\n        message: 'Unable to find a session for refresh',\n      });\n    }\n    const iat = new Date(newIat);\n    session.iat = iat;\n    await this.sessionsRepository.save(session);\n    return;\n  }\n\n  async logout(token: string): Promise<void> {\n    const payload =\n      this.jwtRefreshTokService.verify<CreateRefreshTokenDto>(token);\n    //NOTE: check that refresh token session is active\n    const lastActiveDate = new Date(payload.iat);\n    const session = await this.sessionsRepository.findSessionOrFail(\n      payload.deviceId,\n      lastActiveDate,\n    );\n    return this.sessionsRepository.deleteSession(session);\n  }\n\n  async deleteAnotherSession(\n    token: string,\n    deviceToDelete: string,\n  ): Promise<void> {\n    const payload =\n      this.jwtRefreshTokService.decode<CreateRefreshTokenDto>(token);\n    const deviceId = payload.deviceId;\n\n    //NOTE: check that refresh token session is active\n    const lastActiveDate = new Date(payload.iat);\n    const session = await this.sessionsRepository.findSessionOrFail(\n      deviceId,\n      lastActiveDate,\n    );\n    //NOTE: check that userId is the same in token and in the deviceToDelete\n    const targetSession =\n      await this.sessionsRepository.findSessionByDeviceId(deviceToDelete);\n    if (!targetSession) {\n      throw new DomainException({\n        code: DomainExceptionCode.NotFound,\n        message: 'Session does not exist or already expired',\n      });\n    }\n    if (targetSession.userId !== session.userId) {\n      throw new DomainException({\n        code: DomainExceptionCode.Forbidden,\n        message: 'Could not delete session of another user',\n      });\n    }\n    return this.sessionsRepository.deleteSession(targetSession);\n  }\n\n  async deleteOtherSessions(token: string): Promise<void> {\n    const payload =\n      this.jwtRefreshTokService.decode<CreateRefreshTokenDto>(token);\n    const deviceId = payload.deviceId;\n    const iat = new Date(payload.iat);\n\n    await this.sessionsRepository.findSessionOrFail(deviceId, iat);\n    return this.sessionsRepository.deleteOtherSessions(iat, payload.userId);\n  }\n}\n"],"names":["SessionsService","saveSession","input","domainInput","deviceId","mongoose","Types","ObjectId","expiration","DateTime","utc","plus","Duration","fromMillis","configService","get","toJSDate","session","SessionModel","createSession","sessionsRepository","save","getSession","iat","timestamp","Date","findSessionOrFail","refreshSession","newIat","findSessionByDeviceId","DomainException","code","DomainExceptionCode","InternalServerError","message","logout","token","payload","jwtRefreshTokService","verify","lastActiveDate","deleteSession","deleteAnotherSession","deviceToDelete","decode","targetSession","NotFound","userId","Forbidden","deleteOtherSessions","constructor","name"],"mappings":"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"}