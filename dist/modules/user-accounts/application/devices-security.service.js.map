{"version":3,"sources":["../../../../src/modules/user-accounts/application/devices-security.service.ts"],"sourcesContent":["import { Inject, Injectable } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { DevicesSecurityRepository } from '../infrastructure/devices-security.repository';\nimport { InjectModel } from '@nestjs/mongoose';\nimport {\n  DeviceAuthSession,\n  SessionDocument,\n  SessionModelType,\n} from '../domain/session.entity';\nimport mongoose from 'mongoose';\nimport { CreateSessionDto } from '../dto/create-session.dto';\nimport { DateTime, Duration } from 'luxon';\nimport { ConfigService } from '@nestjs/config';\nimport { ConfigurationType } from 'src/modules/config/config.module';\nimport { DomainException } from 'src/core/exceptions/domain-exceptions';\nimport { DomainExceptionCode } from 'src/core/exceptions/domain-exception-codes';\nimport { CreateRefreshTokenDto } from '../dto/create-refresh-token.dto';\nimport { REFRESH_TOKEN_STRATEGY_INJECT_TOKEN } from '../constants/auth-token.inject-constants';\n\n@Injectable()\nexport class SessionsService {\n  constructor(\n    @InjectModel(DeviceAuthSession.name)\n    private readonly SessionModel: SessionModelType,\n    private readonly sessionsRepository: DevicesSecurityRepository,\n    @Inject(REFRESH_TOKEN_STRATEGY_INJECT_TOKEN)\n    private readonly jwtRefreshTokService: JwtService,\n    private readonly configService: ConfigService<ConfigurationType>,\n  ) {}\n\n  async saveSession(input: CreateSessionDto): Promise<{ deviceId: string }> {\n    const domainInput = {\n      ...input,\n      deviceId: new mongoose.Types.ObjectId(input.deviceId),\n      expiration: DateTime.utc()\n        .plus(\n          Duration.fromMillis(\n            this.configService.get('refreshTokenDuration') * 1000,\n          ),\n        )\n        .toJSDate(),\n    };\n    const session = this.SessionModel.createSession(domainInput);\n\n    const deviceId = await this.sessionsRepository.save(session);\n    return { deviceId };\n  }\n\n  async getSession(deviceId: string, iat: number): Promise<SessionDocument> {\n    const session = await this.sessionsRepository.findSessionOrFail(\n      deviceId,\n      iat,\n    );\n    return session;\n  }\n\n  async refreshSession(deviceId: string, newIat: number): Promise<void> {\n    const session =\n      await this.sessionsRepository.findSessionByDeviceId(deviceId);\n    if (!session) {\n      throw new DomainException({\n        code: DomainExceptionCode.InternalServerError,\n        message: 'Unable to find a session for refresh',\n      });\n    }\n    session.iat = newIat;\n    await this.sessionsRepository.save(session);\n    return;\n  }\n\n  async logout(token: string): Promise<void> {\n    const payload =\n      this.jwtRefreshTokService.verify<CreateRefreshTokenDto>(token);\n    //NOTE: check that refresh token session is active\n    const session = await this.sessionsRepository.findSessionOrFail(\n      payload.deviceId,\n      payload.iat,\n    );\n    return this.sessionsRepository.deleteSession(session);\n  }\n\n  async deleteAnotherSession(\n    token: string,\n    deviceToDelete: string,\n  ): Promise<void> {\n    const payload =\n      this.jwtRefreshTokService.decode<CreateRefreshTokenDto>(token);\n    const deviceId = payload.deviceId;\n\n    //NOTE: check that refresh token session is active\n    const session = await this.sessionsRepository.findSessionOrFail(\n      deviceId,\n      payload.iat,\n    );\n    //NOTE: check that userId is the same in token and in the deviceToDelete\n    const targetSession =\n      await this.sessionsRepository.findSessionByDeviceId(deviceToDelete);\n    if (!targetSession) {\n      throw new DomainException({\n        code: DomainExceptionCode.NotFound,\n        message: 'Session does not exist or already expired',\n      });\n    }\n    if (targetSession.userId !== session.userId) {\n      throw new DomainException({\n        code: DomainExceptionCode.Forbidden,\n        message: 'Could not delete session of another user',\n      });\n    }\n    return this.sessionsRepository.deleteSession(targetSession);\n  }\n\n  async deleteOtherSessions(token: string): Promise<void> {\n    const payload =\n      this.jwtRefreshTokService.decode<CreateRefreshTokenDto>(token);\n    const deviceId = payload.deviceId;\n\n    await this.sessionsRepository.findSessionOrFail(deviceId, payload.iat);\n    return this.sessionsRepository.deleteOtherSessions(\n      payload.iat,\n      payload.userId,\n    );\n  }\n}\n"],"names":["SessionsService","saveSession","input","domainInput","deviceId","mongoose","Types","ObjectId","expiration","DateTime","utc","plus","Duration","fromMillis","configService","get","toJSDate","session","SessionModel","createSession","sessionsRepository","save","getSession","iat","findSessionOrFail","refreshSession","newIat","findSessionByDeviceId","DomainException","code","DomainExceptionCode","InternalServerError","message","logout","token","payload","jwtRefreshTokService","verify","deleteSession","deleteAnotherSession","deviceToDelete","decode","targetSession","NotFound","userId","Forbidden","deleteOtherSessions","constructor","name"],"mappings":"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"}