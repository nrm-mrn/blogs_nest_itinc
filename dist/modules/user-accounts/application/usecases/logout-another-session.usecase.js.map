{"version":3,"sources":["../../../../../src/modules/user-accounts/application/usecases/logout-another-session.usecase.ts"],"sourcesContent":["import { Inject } from '@nestjs/common';\nimport { CommandHandler, ICommandHandler } from '@nestjs/cqrs';\nimport { JwtService } from '@nestjs/jwt';\nimport { REFRESH_TOKEN_STRATEGY_INJECT_TOKEN } from '../../constants/auth-token.inject-constants';\nimport { DevicesSecurityRepository } from '../../infrastructure/devices-security.repository';\nimport { DomainExceptionCode } from 'src/core/exceptions/domain-exception-codes';\nimport { DomainException } from 'src/core/exceptions/domain-exceptions';\nimport { CreateRefreshTokenDto } from '../../dto/create-refresh-token.dto';\n\nexport class LogoutAnotherSessionCommand {\n  constructor(\n    public token: string,\n    public deviceId: string,\n  ) {}\n}\n\n@CommandHandler(LogoutAnotherSessionCommand)\nexport class LogoutAnotherSessionHandler\n  implements ICommandHandler<LogoutAnotherSessionCommand>\n{\n  constructor(\n    private readonly sessionsRepository: DevicesSecurityRepository,\n    @Inject(REFRESH_TOKEN_STRATEGY_INJECT_TOKEN)\n    private readonly jwtRefreshTokService: JwtService,\n  ) {}\n\n  async execute(command: LogoutAnotherSessionCommand): Promise<any> {\n    const payload = this.jwtRefreshTokService.decode<CreateRefreshTokenDto>(\n      command.token,\n    );\n    const deviceId = payload.deviceId;\n\n    //NOTE: check that refresh token session is active\n    const session = await this.sessionsRepository.findSessionOrFail(\n      deviceId,\n      payload.iat,\n    );\n    //NOTE: check that userId is the same in token and in the deviceToDelete\n    const targetSession = await this.sessionsRepository.findSessionByDeviceId(\n      command.deviceId,\n    );\n    if (!targetSession) {\n      throw new DomainException({\n        code: DomainExceptionCode.NotFound,\n        message: 'Session does not exist or already expired',\n      });\n    }\n    if (targetSession.userId !== session.userId) {\n      throw new DomainException({\n        code: DomainExceptionCode.Forbidden,\n        message: 'Could not delete session of another user',\n      });\n    }\n    return this.sessionsRepository.deleteSession(targetSession);\n  }\n}\n"],"names":["LogoutAnotherSessionCommand","LogoutAnotherSessionHandler","constructor","token","deviceId","execute","command","payload","jwtRefreshTokService","decode","session","sessionsRepository","findSessionOrFail","iat","targetSession","findSessionByDeviceId","DomainException","code","DomainExceptionCode","NotFound","message","userId","Forbidden","deleteSession"],"mappings":";;;;;;;;;;;QASaA;eAAAA;;QAQAC;eAAAA;;;wBAjBU;sBACyB;qBACrB;0CACyB;2CACV;sCACN;kCACJ;;;;;;;;;;;;;;;AAGzB,IAAA,AAAMD,8BAAN,MAAMA;IACXE,YACE,AAAOC,KAAa,EACpB,AAAOC,QAAgB,CACvB;aAFOD,QAAAA;aACAC,WAAAA;IACN;AACL;AAGO,IAAA,AAAMH,8BAAN,MAAMA;IASX,MAAMI,QAAQC,OAAoC,EAAgB;QAChE,MAAMC,UAAU,IAAI,CAACC,oBAAoB,CAACC,MAAM,CAC9CH,QAAQH,KAAK;QAEf,MAAMC,WAAWG,QAAQH,QAAQ;QAEjC,kDAAkD;QAClD,MAAMM,UAAU,MAAM,IAAI,CAACC,kBAAkB,CAACC,iBAAiB,CAC7DR,UACAG,QAAQM,GAAG;QAEb,wEAAwE;QACxE,MAAMC,gBAAgB,MAAM,IAAI,CAACH,kBAAkB,CAACI,qBAAqB,CACvET,QAAQF,QAAQ;QAElB,IAAI,CAACU,eAAe;YAClB,MAAM,IAAIE,iCAAe,CAAC;gBACxBC,MAAMC,yCAAmB,CAACC,QAAQ;gBAClCC,SAAS;YACX;QACF;QACA,IAAIN,cAAcO,MAAM,KAAKX,QAAQW,MAAM,EAAE;YAC3C,MAAM,IAAIL,iCAAe,CAAC;gBACxBC,MAAMC,yCAAmB,CAACI,SAAS;gBACnCF,SAAS;YACX;QACF;QACA,OAAO,IAAI,CAACT,kBAAkB,CAACY,aAAa,CAACT;IAC/C;IAlCAZ,YACE,AAAiBS,kBAA6C,EAC9D,AACiBH,oBAAgC,CACjD;aAHiBG,qBAAAA;aAEAH,uBAAAA;IAChB;AA+BL"}